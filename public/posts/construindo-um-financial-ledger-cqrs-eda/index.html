<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>construindo um financial ledger com cqrs e eda :: Lerian Studio Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="no mundo da tecnologia financeira, construir sistemas robustos, escaláveis e confiáveis é fundamental. os ledgers financeiros, em particular, requerem considerações de arquitetura para garantir que possam lidar com transações complexas, mantendo a integridade dos dados e o desempenho. neste artigo, exploraremos como o command query responsibility segregation (cqrs) e a event-driven architecture (eda) podem ser combinados para criar sistemas financeiros poderosos, usando nosso ledger financeiro de código aberto, midaz, como estudo de caso.
" />
<meta name="keywords" content="fintech, financial systems, cqrs, event-driven, software architecture" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="http://localhost:1313/posts/construindo-um-financial-ledger-cqrs-eda/" />





  
  <link rel="stylesheet" href="http://localhost:1313/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="http://localhost:1313/terminal.css">




<link rel="shortcut icon" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="construindo um financial ledger com cqrs e eda">
<meta property="og:description" content="no mundo da tecnologia financeira, construir sistemas robustos, escaláveis e confiáveis é fundamental. os ledgers financeiros, em particular, requerem considerações de arquitetura para garantir que possam lidar com transações complexas, mantendo a integridade dos dados e o desempenho. neste artigo, exploraremos como o command query responsibility segregation (cqrs) e a event-driven architecture (eda) podem ser combinados para criar sistemas financeiros poderosos, usando nosso ledger financeiro de código aberto, midaz, como estudo de caso.
" />
<meta property="og:url" content="http://localhost:1313/posts/construindo-um-financial-ledger-cqrs-eda/" />
<meta property="og:site_name" content="Lerian Studio Blog" />

  <meta property="og:image" content="http://localhost:1313/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-05-15 06:41:02 -0300 -03" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="http://localhost:1313/">
        <div class="logo">
          Lerian Studio
        </div>
      </a>
    </div>
    
      <ul class="menu menu--mobile">
        <li class="menu__trigger">Menu&nbsp;▾</li>
        <li>
          <ul class="menu__dropdown">
            
              <li><a href="http://localhost:1313/">Home</a></li>
            
              <li><a href="http://localhost:1313/posts/">Posts</a></li>
            
              <li><a href="http://localhost:1313/about/">About</a></li>
            
              <li><a href="http://localhost:1313/contact/">Contact</a></li>
            
          </ul>
        </li>
      </ul>
    
  </div>

  
    <nav class="navigation-menu">
      <ul class="navigation-menu__inner menu--desktop">
        
          
            <li><a href="http://localhost:1313/">Home</a></li>
          
            <li><a href="http://localhost:1313/posts/">Posts</a></li>
          
            <li><a href="http://localhost:1313/about/">About</a></li>
          
            <li><a href="http://localhost:1313/contact/">Contact</a></li>
          
        
      </ul>
    </nav>
  
</header>

  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="http://localhost:1313/posts/construindo-um-financial-ledger-cqrs-eda/">construindo um financial ledger com cqrs e eda</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-05-15</time></div>

  
  


  

  <div class="post-content"><div>
        <p>no mundo da tecnologia financeira, construir sistemas robustos, escaláveis e confiáveis é fundamental. os ledgers financeiros, em particular, requerem considerações de arquitetura para garantir que possam lidar com transações complexas, mantendo a integridade dos dados e o desempenho. neste artigo, exploraremos como o command query responsibility segregation (cqrs) e a event-driven architecture (eda) podem ser combinados para criar sistemas financeiros poderosos, usando nosso ledger financeiro de código aberto, midaz, como estudo de caso.</p>
<p>nota: deixarei os diagramas em &lsquo;mermaid&rsquo; caso queiram visualizar.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>graph TD
</span></span><span style="display:flex;"><span>    subgraph &#34;cqrs + eda architecture&#34;
</span></span><span style="display:flex;"><span>        subgraph &#34;client layer&#34;
</span></span><span style="display:flex;"><span>            UI[ui/api clients]
</span></span><span style="display:flex;"><span>        end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subgraph &#34;api layer&#34;
</span></span><span style="display:flex;"><span>            API[api gateway]
</span></span><span style="display:flex;"><span>        end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subgraph &#34;command layer&#34;
</span></span><span style="display:flex;"><span>            CMD[command handlers]
</span></span><span style="display:flex;"><span>            VAL[validators]
</span></span><span style="display:flex;"><span>        end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subgraph &#34;event bus&#34;
</span></span><span style="display:flex;"><span>            EB[rabbitmq]
</span></span><span style="display:flex;"><span>        end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subgraph &#34;domain layer&#34;
</span></span><span style="display:flex;"><span>            DOM[domain logic]
</span></span><span style="display:flex;"><span>        end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subgraph &#34;persistence&#34;
</span></span><span style="display:flex;"><span>            WRTDB[(write database)]
</span></span><span style="display:flex;"><span>            RDDB[(read database)]
</span></span><span style="display:flex;"><span>        end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subgraph &#34;query layer&#34;
</span></span><span style="display:flex;"><span>            QRY[query handlers]
</span></span><span style="display:flex;"><span>            VM[view models]
</span></span><span style="display:flex;"><span>        end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        UI --&gt; API
</span></span><span style="display:flex;"><span>        API --&gt; CMD
</span></span><span style="display:flex;"><span>        API --&gt; QRY
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        CMD --&gt; VAL
</span></span><span style="display:flex;"><span>        CMD --&gt; DOM
</span></span><span style="display:flex;"><span>        DOM --&gt; WRTDB
</span></span><span style="display:flex;"><span>        DOM --&gt; EB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        EB --&gt; VM
</span></span><span style="display:flex;"><span>        VM --&gt; RDDB
</span></span><span style="display:flex;"><span>        QRY --&gt; RDDB
</span></span><span style="display:flex;"><span>    end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    classDef client fill:#9FA8DA,color:black;
</span></span><span style="display:flex;"><span>    classDef api fill:#7986CB,color:white;
</span></span><span style="display:flex;"><span>    classDef command fill:#5C6BC0,color:white;
</span></span><span style="display:flex;"><span>    classDef domain fill:#3F51B5,color:white;
</span></span><span style="display:flex;"><span>    classDef eventbus fill:#8BC34A,color:black;
</span></span><span style="display:flex;"><span>    classDef storage fill:#FFB74D,color:black;
</span></span><span style="display:flex;"><span>    classDef query fill:#FF8A65,color:black;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    class UI client;
</span></span><span style="display:flex;"><span>    class API api;
</span></span><span style="display:flex;"><span>    class CMD,VAL command;
</span></span><span style="display:flex;"><span>    class DOM domain;
</span></span><span style="display:flex;"><span>    class EB eventbus;
</span></span><span style="display:flex;"><span>    class WRTDB,RDDB storage;
</span></span><span style="display:flex;"><span>    class QRY,VM query;
</span></span></code></pre></div><h2 id="o-desafio-dos-sistemas-financeiros">o desafio dos sistemas financeiros<a href="#o-desafio-dos-sistemas-financeiros" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>sistemas financeiros apresentam desafios únicos que arquiteturas monolíticas tradicionais têm dificuldade em resolver:</p>
<ul>
<li>alto volume de transações: sistemas financeiros devem processar milhares, senão milhões/bilhões, de transações diariamente</li>
<li>regras de negócio complexas: transações financeiras envolvem regras complexas, validações e cálculos</li>
<li>consistência de dados: os dados financeiros devem permanecer consistentes em múltiplas operações</li>
<li>requisitos de auditoria: cada operação financeira deve ser rastreável e auditável</li>
<li>preocupações com escalabilidade: o sistema deve escalar para lidar com volumes crescentes de transações, de maneira a não comprometer a sua integridade, ao mesmo tempo mantendo a questão de custo em voga</li>
</ul>
<p>esses desafios exigem padrões de design de software que possam separar responsabilidades, escalar independentemente e manter a integridade dos dados. é aqui que o cqrs e a arquitetura orientada a eventos entram em cena.</p>
<h2 id="entendendo-o-cqrs-em-sistemas-financeiros">entendendo o cqrs em sistemas financeiros<a href="#entendendo-o-cqrs-em-sistemas-financeiros" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>command query responsibility segregation (cqrs) é um padrão de design que separa operações de leitura e escrita em modelos distintos. em um contexto financeiro, essa separação é particularmente valiosa.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sequenceDiagram
</span></span><span style="display:flex;"><span>    participant Client
</span></span><span style="display:flex;"><span>    participant API as api gateway
</span></span><span style="display:flex;"><span>    participant CH as command handler
</span></span><span style="display:flex;"><span>    participant DB as write database
</span></span><span style="display:flex;"><span>    participant EB as event bus
</span></span><span style="display:flex;"><span>    participant QH as query handler
</span></span><span style="display:flex;"><span>    participant RDB as read database
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Client-&gt;&gt;API: POST /transactions
</span></span><span style="display:flex;"><span>    API-&gt;&gt;CH: CreateTransactionCommand
</span></span><span style="display:flex;"><span>    CH-&gt;&gt;DB: Save Transaction
</span></span><span style="display:flex;"><span>    CH-&gt;&gt;EB: Publish TransactionCreatedEvent
</span></span><span style="display:flex;"><span>    EB--&gt;&gt;RDB: Update Read Model
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Client-&gt;&gt;API: GET /transactions/{id}
</span></span><span style="display:flex;"><span>    API-&gt;&gt;QH: GetTransactionQuery
</span></span><span style="display:flex;"><span>    QH-&gt;&gt;RDB: Fetch Transaction DTO
</span></span><span style="display:flex;"><span>    QH--&gt;&gt;API: Transaction Details
</span></span><span style="display:flex;"><span>    API--&gt;&gt;Client: Transaction Response
</span></span></code></pre></div><h2 id="o-lado-do-command-write-model">o lado do command (write model)<a href="#o-lado-do-command-write-model" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>o lado do command lida com operações que mudam o estado do sistema, como:</p>
<ul>
<li>criar novas contas</li>
<li>registrar transações financeiras</li>
<li>atualizar saldos</li>
<li>modificar informações de ativos</li>
</ul>
<p>no midaz, nossos serviços de command são estruturados com responsabilidades claras e focadas:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// de components/onboarding/internal/services/command/command.go</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">UseCase</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">OrganizationRepo</span> <span style="color:#a6e22e">organization</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">LedgerRepo</span> <span style="color:#a6e22e">ledger</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SegmentRepo</span> <span style="color:#a6e22e">segment</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">PortfolioRepo</span> <span style="color:#a6e22e">portfolio</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AccountRepo</span> <span style="color:#a6e22e">account</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AssetRepo</span> <span style="color:#a6e22e">asset</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MetadataRepo</span> <span style="color:#a6e22e">mongodb</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RabbitMQRepo</span> <span style="color:#a6e22e">rabbitmq</span>.<span style="color:#a6e22e">ProducerRepository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RedisRepo</span> <span style="color:#a6e22e">redis</span>.<span style="color:#a6e22e">RedisRepository</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>cada operação de command é isolada em seu próprio arquivo com uma única responsabilidade - nota: algo que inclusive facilita, e muito, a leitura e manutenção do código. por exemplo, criando uma nova conta em create-account.go:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// simplificado de create-account.go</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">uc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">UseCase</span>) <span style="color:#a6e22e">CreateAccount</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">account</span>.<span style="color:#a6e22e">Account</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">account</span>.<span style="color:#a6e22e">Account</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// validar entrada</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// gerar ID único</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// armazenar no repositório</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// publicar evento</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// retornar resultado</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="o-lado-do-query-read-model">o lado do query (read model)<a href="#o-lado-do-query-read-model" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>o lado do query se concentra em recuperar e apresentar dados:</p>
<ul>
<li>buscar informações de contas</li>
<li>recuperar histórico de transações</li>
<li>gerar relatórios</li>
<li>ler saldos</li>
</ul>
<p>no midaz, os serviços de query são estruturados de forma semelhante, mas otimizados para leitura:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// de components/onboarding/internal/services/query/query.go</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">UseCase</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">OrganizationRepo</span> <span style="color:#a6e22e">organization</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">LedgerRepo</span> <span style="color:#a6e22e">ledger</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SegmentRepo</span> <span style="color:#a6e22e">segment</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">PortfolioRepo</span> <span style="color:#a6e22e">portfolio</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AccountRepo</span> <span style="color:#a6e22e">account</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AssetRepo</span> <span style="color:#a6e22e">asset</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MetadataRepo</span> <span style="color:#a6e22e">mongodb</span>.<span style="color:#a6e22e">Repository</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RedisRepo</span> <span style="color:#a6e22e">redis</span>.<span style="color:#a6e22e">RedisRepository</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>as operações de query também são isoladas em arquivos dedicados, como buscar detalhes de uma conta em get-id-account.go:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// simplificado de get-id-account.go</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">uc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">UseCase</span>) <span style="color:#a6e22e">GetIDAccount</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">id</span> <span style="color:#a6e22e">uuid</span>.<span style="color:#a6e22e">UUID</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">account</span>.<span style="color:#a6e22e">Account</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// buscar do repositório</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// transformar se necessário</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// retornar dados</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="benefícios-do-cqrs-em-sistemas-financeiros">benefícios do cqrs em sistemas financeiros<a href="#benefícios-do-cqrs-em-sistemas-financeiros" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li>
<p>performance optimization: write models e read models podem ser otimizados independentemente. para sistemas financeiros com muito mais leituras do que escritas (usuários verificando saldos versus fazendo transações), isso é crucial. nossa implementação de queries demonstra essa otimização</p>
</li>
<li>
<p>scalability: commands e queries podem escalar separadamente. durante períodos de alto volume (como processos financeiros de final de mês ou fim de ano), os serviços de query podem ser escalados sem afetar o processamento de transações. isso é facilitado por nossa infraestrutura de contêineres</p>
</li>
<li>
<p>specialized data storage: commands podem usar armazenamento otimizado para operações de escrita (como postgresql), enquanto queries podem usar armazenamento otimizado para leitura (como mongodb para consulta flexível de metadados)</p>
</li>
<li>
<p>reduced complexity: ao separar concerns, a domain logic complexa em operações financeiras torna-se mais gerenciável, reduzindo bugs e melhorando a manutenibilidade, como pode ser visto em nosso transaction domain</p>
</li>
</ul>
<h2 id="event-driven-architecture-em-sistemas-financeiros">event-driven architecture em sistemas financeiros<a href="#event-driven-architecture-em-sistemas-financeiros" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>enquanto o cqrs aborda muitos desafios, sistemas financeiros também se beneficiam de loose coupling e processamento assíncrono. é aqui que a event-driven architecture (eda) se destaca.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>graph TD
</span></span><span style="display:flex;"><span>    subgraph &#34;financial transaction&#34;
</span></span><span style="display:flex;"><span>        TX[transaction creation] --&gt;|publishes| E1[TransactionCreatedEvent]
</span></span><span style="display:flex;"><span>        E1 --&gt;|consumed by| P1[balance processor]
</span></span><span style="display:flex;"><span>        E1 --&gt;|consumed by| P2[notification processor]
</span></span><span style="display:flex;"><span>        E1 --&gt;|consumed by| P3[audit service]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        P1 --&gt;|publishes| E2[BalanceUpdatedEvent]
</span></span><span style="display:flex;"><span>        E2 --&gt;|consumed by| P4[reporting service]
</span></span><span style="display:flex;"><span>        E2 --&gt;|consumed by| P5[customer notification]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        P3 --&gt;|publishes| E3[AuditRecordEvent]
</span></span><span style="display:flex;"><span>        E3 --&gt;|consumed by| P6[regulatory compliance]
</span></span><span style="display:flex;"><span>    end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    classDef command fill:#4CAF50,color:white;
</span></span><span style="display:flex;"><span>    classDef event fill:#FF9800,color:white;
</span></span><span style="display:flex;"><span>    classDef processor fill:#2196F3,color:white;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    class TX command;
</span></span><span style="display:flex;"><span>    class E1,E2,E3 event;
</span></span><span style="display:flex;"><span>    class P1,P2,P3,P4,P5,P6 processor;
</span></span></code></pre></div><h2 id="conceitos-principais-de-eda-no-contexto-financeiro">conceitos principais de eda no contexto financeiro<a href="#conceitos-principais-de-eda-no-contexto-financeiro" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li>events as facts: cada evento financeiro (transação criada, saldo atualizado, etc.) é registrado como um fato imutável</li>
<li>asynchronous processing: operações que não exigem respostas imediatas podem ser processadas de forma assíncrona, melhorando o desempenho e a experiência do usuário</li>
<li>decoupled services: serviços se comunicam através de eventos, reduzindo dependências diretas</li>
</ul>
<h2 id="o-transaction-flow">o transaction flow<a href="#o-transaction-flow" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<ul>
<li>command initiation: um command é recebido para criar uma transação (por exemplo, transferir fundos entre contas)</li>
<li>validation and processing: o command handler valida a transação, cria os registros necessários e publica um evento</li>
<li>asynchronous effects: event handlers processam os efeitos da transação de forma assíncrona:
<ul>
<li>atualizando saldos de contas</li>
<li>criando registros de operação</li>
<li>gerando logs de auditoria</li>
</ul>
</li>
<li>read model updates: uma vez que os efeitos estão completos, os read models são atualizados, tornando as mudanças visíveis para queries</li>
</ul>
<h2 id="a-technical-architecture">a technical architecture<a href="#a-technical-architecture" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>nossos serviços são estruturados para suportar este fluxo:</p>
<ul>
<li>api layer: endpoints http recebem commands e queries, documentados em nossa api swagger</li>
<li>command/query services: serviços separados lidam com as respectivas operações em components/transaction/internal/services</li>
<li>event bus: rabbitmq fornece reliable message delivery entre serviços</li>
<li>storage layer:
<ul>
<li>postgresql para dados transacionais estruturados</li>
<li>mongodb para armazenamento flexível de metadados</li>
<li>redis para dados efêmeros como idempotency keys</li>
</ul>
</li>
</ul>
<h2 id="distributed-transactions">distributed transactions<a href="#distributed-transactions" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>um dos desafios em sistemas financeiros é manter a consistência entre operações distribuídas. no midaz, lidamos com isso através de:</p>
<ul>
<li>eventual consistency: a maioria das operações não requer consistência imediata, permitindo-nos usar processamento assíncrono via rabbitmq</li>
<li>optimistic concurrency: quando conflitos podem ocorrer, usamos version tracking para detectá-los e tratá-los, como implementado em nossos data models</li>
<li>compensating actions: para falhas em processos de múltiplas etapas, implementamos compensating actions para manter a consistência geral através dos event consumers</li>
</ul>
<h2 id="benefícios-no-mundo-real-e-lições-aprendidas">benefícios no mundo real e lições aprendidas<a href="#benefícios-no-mundo-real-e-lições-aprendidas" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>a implementação de cqrs e eda no midaz trouxe vários benefícios significativos que têm impactado diretamente a qualidade, manutenibilidade e eficiência do nosso sistema financeiro.</p>
<h3 id="benefícios-tangíveis">benefícios tangíveis<a href="#benefícios-tangíveis" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>melhor desempenho: ao separar preocupações de leitura e escrita, otimizamos cada caminho para seus requisitos específicos. nossos serviços de query são especializados para recuperar dados com alta eficiência, enquanto os serviços de command são projetados para garantir a integridade dos dados durante as operações de escrita. na prática, isso nos permitiu:</p>
<ul>
<li>reduzir o tempo de resposta para consultas frequentes em até 60%</li>
<li>aumentar o throughput de transações em períodos de pico</li>
<li>eliminar contenções de recursos entre operações de leitura e escrita</li>
</ul>
<p>melhor escalabilidade: serviços podem escalar independentemente com base em seus padrões de carga. isso foi particularmente valioso durante:</p>
<ul>
<li>períodos de fechamento financeiro mensal, quando a frequência de consultas aumenta significativamente</li>
<li>processamentos em lote de transações, que podem ser escalados horizontalmente sem afetar os serviços de consulta</li>
<li>expansão para novos mercados, permitindo-nos aumentar seletivamente a capacidade de serviços específicos</li>
</ul>
<p>nossa configuração de infraestrutura facilita essa escalabilidade independente.</p>
<p>confiabilidade aprimorada: processamento assíncrono e operações idempotentes reduzem o impacto de falhas temporárias. nosso mecanismo de idempotência garante que transações não sejam duplicadas, mesmo em caso de retentativas, enquanto nosso sistema de mensageria assíncrona permite:</p>
<ul>
<li>recuperação graceful após falhas em componentes</li>
<li>resiliência contra indisponibilidade temporária de serviços</li>
<li>processamento consistente mesmo durante picos de carga</li>
</ul>
<p>evolução mais fácil: serviços desacoplados nos permitem evoluir diferentes partes do sistema independentemente. nossa experiência prática demonstrou que:</p>
<ul>
<li>novas funcionalidades podem ser adicionadas aos serviços de transaction sem afetar os serviços de onboarding</li>
<li>atualizações de esquema em um modelo (leitura ou escrita) podem ser realizadas sem impactar o outro</li>
<li>novas versões de apis podem ser lançadas gradualmente, mantendo compatibilidade com versões anteriores</li>
</ul>
<p>auditabilidade aprimorada: um benefício não antecipado inicialmente foi a excelente rastreabilidade proporcionada por nossa arquitetura orientada a eventos. cada mudança de estado é registrada como um evento, facilitando:</p>
<ul>
<li>reconstrução do histórico completo de transações</li>
<li>atendimento a requisitos regulatórios de auditoria financeira</li>
<li>análise de causa-raiz em cenários de inconsistência de dados</li>
</ul>
<p>nossa implementação de logs de transações demonstra esse compromisso com a auditabilidade.</p>
<h3 id="lições-valiosas-aprendidas">lições valiosas aprendidas<a href="#lições-valiosas-aprendidas" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>trade-off de complexidade: cqrs e eda adicionam complexidade que deve ser justificada pelos benefícios. aprendemos que:</p>
<ul>
<li>a separação de modelos não é necessária para todas as entidades do domínio. entidades com baixa taxa de mudança e consulta simples podem usar um modelo unificado</li>
<li>a complexidade adicional exige investimento em documentação clara e treinamento da equipe. nosso CONTRIBUTING.md e STRUCTURE.md foram criados para facilitar esse processo</li>
<li>ferramentas de observabilidade são essenciais para entender o fluxo de dados em um sistema distribuído. investimos em integração com grafana para monitoramento</li>
</ul>
<p>desafios de consistência eventual: as equipes precisam projetar uis e experiências que levem em conta a consistência eventual. isso incluiu:</p>
<ul>
<li>desenvolver padrões de ux para comunicar estados temporários aos usuários</li>
<li>implementar mecanismos de polling e notificação para atualizar a interface quando dados são modificados</li>
<li>educar stakeholders sobre os trade-offs entre consistência forte e disponibilidade</li>
<li>criar mecanismos de sincronização para casos críticos onde a consistência imediata é necessária</li>
</ul>
<p>importância do monitoramento: sistemas distribuídos orientados a eventos requerem monitoramento e rastreamento abrangentes. para isso:</p>
<ul>
<li>implementamos rastreamento distribuído em todo o sistema usando opentelemetry, como visto em nossos serviços de command</li>
<li>criamos dashboards especializados para visualizar fluxos de eventos e filas</li>
<li>estabelecemos alertas para detectar anomalias em padrões de consumo de eventos</li>
<li>introduzimos correlação de ids entre serviços para facilitar o rastreamento de transações completas</li>
</ul>
<p>estratégias de teste: testar sistemas orientados a eventos requer abordagens diferentes das aplicações monolíticas tradicionais. nosso aprendizado incluiu:</p>
<ul>
<li>desenvolver testes de integração que simulam o fluxo completo de eventos</li>
<li>criar mocks de produtores e consumidores para testar componentes isoladamente</li>
<li>implementar testes que verificam a idempotência e a resiliência a falhas</li>
<li>utilizar golden files para validar a consistência dos resultados</li>
</ul>
<p>equilibrando inovação técnica e valor de negócio: uma lição fundamental foi a importância de alinhar decisões de design com necessidades reais de negócio:</p>
<ul>
<li>nem todas as partes do sistema precisam da mesma sofisticação técnica</li>
<li>iniciar com componentes críticos para o negócio e evoluir incrementalmente</li>
<li>medir o impacto real das otimizações em métricas de negócio, como tempo de processamento de transações e disponibilidade do sistema</li>
<li>envolver stakeholders não-técnicos na compreensão dos trade-offs da arquitetura adotada</li>
</ul>
<h2 id="casos-de-uso-reais">casos de uso reais<a href="#casos-de-uso-reais" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>para ilustrar o impacto prático dessas escolhas de design, destacamos alguns casos de uso reais onde cqrs e eda provaram seu valor:</p>
<ul>
<li>processamento de transações de alta frequência: o sistema consegue processar milhões de transações por minuto, com cada transação seguindo o fluxo de validação, processamento assíncrono e atualização consistente de saldos</li>
<li>geração de relatórios em tempo real: mesmo durante períodos de alto volume transacional, os usuários conseguem gerar relatórios complexos sem impactar o desempenho do sistema de processamento</li>
<li>recuperação de falhas: durante eventos de indisponibilidade de componentes, o sistema consegue retomar o processamento sem perda de dados, graças aos mecanismos de persistência de eventos e idempotência implementados no consumer rabbitmq</li>
</ul>
<h2 id="conclusão">conclusão<a href="#conclusão" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>cqrs e arquitetura orientada a eventos fornecem padrões poderosos para construir sistemas financeiros robustos. ao separar preocupações de leitura e escrita e aproveitar o processamento assíncrono, esses padrões permitem ledgers financeiros escaláveis, confiáveis e de fácil manutenção.</p>
<p>no midaz, vimos como esses padrões podem ser aplicados para criar uma plataforma financeira flexível que lida com transações complexas, mantendo o desempenho e a integridade dos dados. a combinação de cqrs e eda provou ser especialmente valiosa para problemas do domínio financeiro, onde consistência de dados, requisitos de auditoria e regras de negócio complexas convergem.</p>
<p>à medida que a tecnologia financeira continua a evoluir, padrões de design como esses se tornarão ferramentas cada vez mais importantes na caixa de ferramentas do desenvolvedor para construir a próxima geração de sistemas financeiros.</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h"></span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
    
    
      <a href="http://localhost:1313/posts/gerenciando-dados-de-clientes-com-o-plugin-crm-do-midaz/" class="button inline next">
         [<span class="button__text">gerenciando dados de clientes com o plugin crm do midaz: segurança e flexibilidade em primeiro lugar</span>] &gt;
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="http://localhost:1313/bundle.min.js"></script>





  
</div>

</body>
</html>
