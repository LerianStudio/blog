<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>lições aprendidas na construção de uma sdk financeira: onde termina o backend e começa o cliente? :: Lerian Studio Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="nas últimas semanas, embarcamos em um desafio por aqui: construir a primeira SDK para o Midaz, nosso ledger para core banking (disponível open-source aqui). o que parecia ser um projeto simples &ndash; afinal, openapi documentation e uma infinidade de ferramentas para generation &ndash;, rapidamente se transformou em um rabbit hole técnico bem profundo. colocar a primeira versão em produção trouxe à tona uma discussão fundamental: qual é a fronteira entre as responsabilidades do servidor e do cliente?
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="http://localhost:1313/posts/licoes-aprendidas-na-construcao-de-uma-sdk-financeira/" />





  
  <link rel="stylesheet" href="http://localhost:1313/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="lições aprendidas na construção de uma sdk financeira: onde termina o backend e começa o cliente?">
<meta property="og:description" content="nas últimas semanas, embarcamos em um desafio por aqui: construir a primeira SDK para o Midaz, nosso ledger para core banking (disponível open-source aqui). o que parecia ser um projeto simples &ndash; afinal, openapi documentation e uma infinidade de ferramentas para generation &ndash;, rapidamente se transformou em um rabbit hole técnico bem profundo. colocar a primeira versão em produção trouxe à tona uma discussão fundamental: qual é a fronteira entre as responsabilidades do servidor e do cliente?
" />
<meta property="og:url" content="http://localhost:1313/posts/licoes-aprendidas-na-construcao-de-uma-sdk-financeira/" />
<meta property="og:site_name" content="Lerian Studio Blog" />

  <meta property="og:image" content="http://localhost:1313/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-05-15 06:41:02 -0300 -03" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="http://localhost:1313/">
  <div class="logo">
    Lerian Studio Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="http://localhost:1313/about">About</a></li>
        
      
        
          <li><a href="http://localhost:1313/posts">Posts</a></li>
        
      
        
          <li><a href="http://localhost:1313/contact">Contact</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="http://localhost:1313/about" >About</a></li>
        
      
        
          <li><a href="http://localhost:1313/posts" >Posts</a></li>
        
      
        
          <li><a href="http://localhost:1313/contact" >Contact</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="http://localhost:1313/posts/licoes-aprendidas-na-construcao-de-uma-sdk-financeira/">lições aprendidas na construção de uma sdk financeira: onde termina o backend e começa o cliente?</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-05-15&nbsp;[Updated 2025-05-15]</time><span class="post-reading-time">19 min read (3852 words)</span></div>

  
  


  
    <div class="table-of-contents">
      <h2>
        Table of Contents
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#fronteiras-de-responsabilidade">fronteiras de responsabilidade</a></li>
    <li><a href="#por-que-uma-sdk-robusta-importa">por que uma sdk robusta importa?</a></li>
    <li><a href="#validação-no-cliente-evitando-viagens-desnecessárias">validação no cliente: evitando viagens desnecessárias</a></li>
    <li><a href="#resiliência-através-de-retry-inteligente">resiliência através de retry inteligente</a></li>
    <li><a href="#gerenciamento-avançado-de-configurações">gerenciamento avançado de configurações</a></li>
    <li><a href="#performance-otimizada-para-json">performance otimizada para JSON</a></li>
    <li><a href="#páginação-inteligente-e-universal">páginação inteligente e universal</a></li>
    <li><a href="#tratamento-avançado-de-erros-financeiros">tratamento avançado de erros financeiros</a></li>
    <li><a href="#documentação-direcionada-por-exemplos">documentação direcionada por exemplos</a></li>
    <li><a href="#trade-offs-e-desafios-de-design-importantes">trade-offs e desafios de design importantes</a></li>
    <li><a href="#estratégia-de-versionamento-e-compatibilidade-planejado-para-em-breve-dado-que-estamos-na-v1-do-midaz">estratégia de versionamento e compatibilidade planejado para em breve, dado que estamos na V1 do Midaz</a></li>
    <li><a href="#aprendizados-para-o-futuro">aprendizados para o futuro</a></li>
    <li><a href="#o-padrão-functional-options-flexibilidade-sem-complexidade">o padrão functional options: flexibilidade sem complexidade</a></li>
    <li><a href="#conclusão">conclusão</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <p>nas últimas semanas, embarcamos em um desafio por aqui: construir a primeira SDK para o Midaz, nosso ledger para core banking (disponível open-source aqui). o que parecia ser um projeto simples &ndash; afinal, openapi documentation e uma infinidade de ferramentas para generation &ndash;, rapidamente se transformou em um rabbit hole técnico bem profundo. colocar a primeira versão em produção trouxe à tona uma discussão fundamental: qual é a fronteira entre as responsabilidades do servidor e do cliente?</p>
<h2 id="fronteiras-de-responsabilidade">fronteiras de responsabilidade<a href="#fronteiras-de-responsabilidade" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>quando começamos a desenvolver a SDK para o Midaz (em Go), a pergunta que constantemente nos perseguia era: até onde a API do backend deve ir e onde começa a responsabilidade de integração/implementação do cliente? ou seja, onde termina o backend e começa o colo do cliente?</p>
<p>esta pergunta aparentemente simples esconde uma complexidade enorme. tradicionalmente, muitos desenvolvedores consideram que:</p>
<ul>
<li><strong>backend</strong>: responsável pela lógica de negócio, persistência, segurança, validações</li>
<li><strong>cliente/sdk</strong>: responsável apenas por fazer requisições HTTP, serializar/deserializar dados</li>
</ul>
<p>mas será que essa divisão simplista funciona bem na prática? especialmente quando falamos de sistemas financeiros com requisitos rigorosos de consistência, performance e resiliência?</p>
<h2 id="por-que-uma-sdk-robusta-importa">por que uma sdk robusta importa?<a href="#por-que-uma-sdk-robusta-importa" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>durante o desenvolvimento, percebemos que uma sdk financeira precisa ir muito além de simplesmente fazer o wrapping de endpoints REST. ela precisa ser uma camada que:</p>
<ol>
<li>protege o servidor contra inputs inválidos (validação do lado cliente)</li>
<li>torna a integração mais resiliente (retries, rate limiting, circuit breaking)</li>
<li>oferece performance mesmo em condições adversas (batching, paralelismo)</li>
<li>simplifica operações complexas (abstraindo detalhes de implementação)</li>
<li>proporciona uma experiência de desenvolvimento fluida (tipos fortemente definidos, erros descritivos)</li>
</ol>
<p>vamos explorar cada um desses aspectos detalhadamente, com exemplos práticos do que implementamos na nossa primeira sdk.</p>
<h2 id="validação-no-cliente-evitando-viagens-desnecessárias">validação no cliente: evitando viagens desnecessárias<a href="#validação-no-cliente-evitando-viagens-desnecessárias" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>uma das primeiras decisões que tomamos foi implementar validações robustas no lado cliente. por quê? simples: por que enviar ao servidor uma requisição que sabemos que vai falhar?</p>

  <pre><code class="language-go">// exemplo de validação de transação financeira no lado cliente
func ValidateTransactionDSL(input TransactionDSLValidator) error {
    if input == nil {
        return fmt.Errorf(&#34;transaction input cannot be nil&#34;)
    }

    // valida código do ativo
    asset := input.GetAsset()
    if asset == &#34;&#34; {
        return fmt.Errorf(&#34;asset code is required&#34;)
    }
    if !assetCodePattern.MatchString(asset) {
        return fmt.Errorf(&#34;invalid asset code format: %s (must be 3-4 uppercase letters)&#34;, asset)
    }

    // valida valor
    if input.GetValue() &lt;= 0 {
        return fmt.Errorf(&#34;transaction amount must be greater than zero&#34;)
    }

    // validações adicionais de contas e consistência...
}</code></pre>

<p>implementamos validações para:</p>
<ul>
<li>formatos de código de ativos (USD, BRL, BTC, Gado, Caixas de Remédio, whatever)</li>
<li>montantes e escalas de transações</li>
<li>estrutura de contas e operações</li>
<li>metadados e payloads auxiliares</li>
</ul>
<p>isso traz múltiplos benefícios:</p>
<ul>
<li>feedback instantâneo para o desenvolvedor</li>
<li>redução de latência (evitando roundtrips desnecessários)</li>
<li>menor carga no servidor</li>
<li>mensagens de erro mais contextualizadas e úteis</li>
</ul>
<p>a validação no cliente não substitui a validação no servidor (que continua essencial por razões de segurança), mas cria uma experiência de desenvolvimento superior e reduz o tráfego de rede.</p>
<h2 id="resiliência-através-de-retry-inteligente">resiliência através de retry inteligente<a href="#resiliência-através-de-retry-inteligente" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>sistemas distribuídos falham. esta é uma realidade, não uma possibilidade. quando trabalhamos com operações financeiras, essas falhas são ainda mais críticas e podem ter consequências significativas.</p>
<p>por isso, implementamos mecanismos sofisticados de retry com exponential backoff:</p>

  <pre><code class="language-go">// configuração de retry com backoff exponencial
client, err := client.New(
    client.WithAuthToken(&#34;your-auth-token&#34;),
    client.WithTimeout(30 * time.Second),
    client.WithRetries(3, 100*time.Millisecond, 1*time.Second),
    client.UseAllAPIs(), // by the way, isso é um caso a parte aqui: pra que expor o que não precisa ser exposto?
)</code></pre>

<p>nosso sistema de retry:</p>
<ul>
<li>utiliza backoff exponencial para evitar sobrecarregar servidores em problemas</li>
<li>adiciona jitter (variação aleatória) para prevenir thundering herd</li>
<li>categoriza erros entre &ldquo;retryable&rdquo; e &ldquo;non-retryable&rdquo;</li>
<li>respeita limites de timeout especificados pelo usuário</li>
<li>permite personalização completa de estratégias</li>
</ul>
<p>este código parece simples na interface, mas por trás dele há uma implementação robusta que considera diversos cenários de falha:</p>

  <pre><code class="language-go">// trecho da implementação de retry com backoff
func doWithOptions(ctx context.Context, fn func() error, options *Options) error {
    var err error
    for attempt := 0; attempt &lt;= options.MaxRetries; attempt&#43;&#43; {
        // Check if context is done before executing
        if ctx.Err() != nil {
            return fmt.Errorf(&#34;operation cancelled: %w&#34;, ctx.Err())
        }

        // Execute the function
        err = fn()
        if err == nil {
            // Success, return immediately
            return nil
        }

        // Check if this is the last attempt
        if attempt == options.MaxRetries {
            break
        }

        // Check if the error is retryable
        if !IsRetryableError(err, options) {
            return err
        }

        // Calculate delay with jitter
        delay := calculateBackoff(attempt, options)
        delayWithJitter := addJitter(delay, options.JitterFactor)

        // Wait for the calculated delay or until context is done
        timer := time.NewTimer(delayWithJitter)
        select {
        case &lt;-ctx.Done():
            timer.Stop()
            return fmt.Errorf(&#34;operation cancelled during retry: %w&#34;, ctx.Err())
        case &lt;-timer.C:
            // Continue to next retry attempt
        }
    }

    return fmt.Errorf(&#34;operation failed after %d retries: %w&#34;, options.MaxRetries, err)
}</code></pre>

<p>Um dos aprendizados mais interessantes foi identificar quais erros deveriam ser tentados novamente e quais não. Por exemplo, erros de validação nunca devem ter retry, enquanto problemas de rede temporários são candidatos ideais. Este modelo de listing by exception é um conceito que foi estudado bastante, e foi aplicado em outras enterprise-grade APIs (exemplo interessante é a da AWS).</p>

  <pre><code class="language-go">// definição de erros retryable padrão
var DefaultRetryableErrors = []string{
    &#34;connection reset by peer&#34;,
    &#34;connection refused&#34;,
    &#34;timeout&#34;,
    &#34;deadline exceeded&#34;,
    &#34;too many requests&#34;,
    &#34;rate limit&#34;,
    &#34;service unavailable&#34;,
}

// códigos HTTP que merecem retry
var DefaultRetryableHTTPCodes = []int{
    http.StatusRequestTimeout,      // 408
    http.StatusTooManyRequests,     // 429
    http.StatusInternalServerError, // 500
    http.StatusBadGateway,          // 502
    http.StatusServiceUnavailable,  // 503
    http.StatusGatewayTimeout,      // 504
}</code></pre>

<h2 id="gerenciamento-avançado-de-configurações">gerenciamento avançado de configurações<a href="#gerenciamento-avançado-de-configurações" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>a modularidade da configuração foi um ponto crítico do design. utilizamos o padrão de opções funcionais (não são 100% fluentes como pede o figurin) para permitir uma configuração limpa e extensível:</p>

  <pre><code class="language-go">// padrão de options funcionais para configuração flexível
client, err := client.New(
    // configurações básicas
    client.WithAuthToken(&#34;your-auth-token&#34;),
    client.WithEnvironment(config.EnvironmentProduction),

    // opções avançadas de performance
    client.WithTimeout(30 * time.Second),
    client.WithRetries(3, 200*time.Millisecond, 2*time.Second),

    // observabilidade
    client.WithObservability(true, true, true),

    // quais APIs utilizar
    client.UseAllAPIs(),
)</code></pre>

<p>este padrão permite:</p>
<ul>
<li>configuração incremental com defaults sensatos</li>
<li>melhor legibilidade e manutenção</li>
<li>extensibilidade futura sem quebrar compatibilidade</li>
<li>configurações específicas por domínio</li>
</ul>
<p>Além disso, implementamos suporte para configuração via variáveis de ambiente:</p>

  <pre><code class="language-go">// variáveis de ambiente que o cliente reconhece
MIDAZ_AUTH_TOKEN=seu-token // implementaremos a sdk de access management lançada ontem logo logo
MIDAZ_ENVIRONMENT=production
MIDAZ_ONBOARDING_URL=https://api.exemplo.com/v1
MIDAZ_TRANSACTION_URL=https://transactions.exemplo.com/v1
MIDAZ_DEBUG=true
MIDAZ_MAX_RETRIES=5</code></pre>

<p>isso permite uma integração mais suave com diferentes ambientes de deploy, especialmente em contextos de containers e kubernetes.</p>
<h2 id="performance-otimizada-para-json">performance otimizada para JSON<a href="#performance-otimizada-para-json" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Em sistemas financeiros, performance não é luxo, é requisito. Um dos pontos de maior otimização foi o processamento JSON, que pode rapidamente se tornar um gargalo:</p>

  <pre><code class="language-go">// exemplo de nossa implementação de pooling de buffers para JSON
type JSONPerformance struct {
    encoderPool sync.Pool
    decoderPool sync.Pool
    bufferPool  sync.Pool
}

func NewJSONPerformance() *JSONPerformance {
    return &amp;JSONPerformance{
        encoderPool: sync.Pool{
            New: func() interface{} {
                return json.NewEncoder(io.Discard)
            },
        },
        decoderPool: sync.Pool{
            New: func() interface{} {
                return json.NewDecoder(strings.NewReader(&#34;&#34;))
            },
        },
        bufferPool: sync.Pool{
            New: func() interface{} {
                return new(bytes.Buffer)
            },
        },
    }
}

func (jp *JSONPerformance) Marshal(v interface{}) ([]byte, error) {
    buf := jp.bufferPool.Get().(*bytes.Buffer)
    buf.Reset()
    defer jp.bufferPool.Put(buf)

    enc := jp.encoderPool.Get().(*json.Encoder)
    enc.SetEscapeHTML(false)
    oldWriter := enc.Linter
    enc.SetWriter(buf)
    defer func() {
        enc.SetWriter(oldWriter)
        jp.encoderPool.Put(enc)
    }()

    if err := enc.Encode(v); err != nil {
        return nil, err
    }

    // Copy to avoid returning a reference to the pooled buffer
    result := make([]byte, buf.Len())
    copy(result, buf.Bytes())
    return result, nil
}</code></pre>

<p>Esta abordagem reduziu alocações de memória em nossos benchmarks, principalmente quando fazíamos em conjunto com o pooling de buffers, o que é crucial para sistemas financeiros de alto volume que processam milhões de transações.</p>
<h2 id="páginação-inteligente-e-universal">páginação inteligente e universal<a href="#páginação-inteligente-e-universal" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Lidar com grandes conjuntos de dados é um desafio comum em operações financeiras. Por isso, desenvolvemos um sistema de paginação universal que funciona com diferentes endpoints e paradigmas:</p>

  <pre><code class="language-go">// interface genérica para qualquer tipo de paginador
type Paginator[T any] interface {
    HasNext() bool
    Next() (*ListResponse[T], error)
    Reset()
}

// exemplo de uso para listar transações com paginação automática
paginator := client.Entity.Transactions.GetTransactionPaginator(
    ctx, &#34;org-id&#34;, &#34;ledger-id&#34;, &amp;models.ListOptions{Limit: 100},
)

totalTransactions := 0
for paginator.HasNext() {
    page, err := paginator.Next()
    if err != nil {
        return err
    }

    for _, tx := range page.Items {
        // processar cada transação
        processTransaction(tx)
        totalTransactions&#43;&#43;
    }
}
fmt.Printf(&#34;Processadas %d transações no total\n&#34;, totalTransactions)</code></pre>

<p>Nossa implementação suporta:</p>
<ul>
<li>páginação por offset/limit (mais comum)</li>
<li>páginação por cursor (mais eficiente para grandes datasets)</li>
<li>prefetching para melhor performance</li>
<li>preservação de filtros e ordenação entre páginas</li>
<li>adaptação automática ao tipo de paginação do endpoint</li>
<li>concorrência controlada para alto volume</li>
</ul>
<p>Para lidar com os requisitos de alta performance, investimos pesadamente em modelos de concorrência bem controlados:</p>

  <pre><code class="language-go">// worker pool genérico com controle fino de concorrência
func WorkerPool[T, R any](
    ctx context.Context,
    items []T,
    workFn func(context.Context, T) (R, error),
    opts ...PoolOption,
) []Result[T, R] {
    // Config default
    options := defaultPoolOptions()
    for _, opt := range opts {
        opt(options)
    }

    resultCh := make(chan Result[T, R], len(items))
    var wg sync.WaitGroup

    // semáforo para controlar concorrência
    sem := make(chan struct{}, options.workers)

    // Rate limiter se especificado
    var limiter &lt;-chan time.Time
    if options.rateLimit &gt; 0 {
        ticker := time.NewTicker(time.Second / time.Duration(options.rateLimit))
        defer ticker.Stop()
        limiter = ticker.C
    }

    for i, item := range items {
        // Respeita cancelamento pelo context
        if ctx.Err() != nil {
            break
        }

        // Rate limiting se ativo
        if limiter != nil {
            select {
            case &lt;-ctx.Done():
                break
            case &lt;-limiter:
                // Continue quando o rate limiter permitir
            }
        }

        // Adquire slot no semáforo
        sem &lt;- struct{}{}

        wg.Add(1)
        go func(idx int, item T) {
            defer wg.Done()
            defer func() { &lt;-sem }() // Libera o semáforo ao final

            // Cria um timeout interno se necessário
            execCtx := ctx
            if options.timeout &gt; 0 {
                var cancel context.CancelFunc
                execCtx, cancel = context.WithTimeout(ctx, options.timeout)
                defer cancel()
            }

            // Executa a função de trabalho
            result, err := workFn(execCtx, item)

            // Envia o resultado
            resultCh &lt;- Result[T, R]{
                Index: idx,
                Item:  item,
                Value: result,
                Error: err,
            }
        }(i, item)
    }

    // Fecha o canal de resultados quando todo trabalho estiver concluído
    go func() {
        wg.Wait()
        close(resultCh)
    }()

    // Coleta resultados
    var results []Result[T, R]
    for result := range resultCh {
        results = append(results, result)
    }

    // Ordena resultados se necessário
    if options.ordered {
        sort.Slice(results, func(i, j int) bool {
            return results[i].Index &lt; results[j].Index
        })
    }

    return results
}</code></pre>

<p>Esta implementação permite:</p>
<ul>
<li>Controle preciso de concorrência para evitar sobrecarregar a API</li>
<li>Rate limiting para respeitar limites da API</li>
<li>Ordenação opcional de resultados</li>
<li>Cancelamento gracioso de operações em andamento</li>
<li>Timeouts individuais para tarefas</li>
</ul>
<h2 id="tratamento-avançado-de-erros-financeiros">tratamento avançado de erros financeiros<a href="#tratamento-avançado-de-erros-financeiros" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Em um sistema financeiro, os erros são parte crítica da experiência do desenvolvedor. Investimos em um sistema sofisticado de tratamento de erros:</p>

  <pre><code class="language-go">// exemplo de uso de erros especializados
switch {
case errors.IsValidationError(err):
    // Trata erro de validação
    fmt.Println(&#34;Erro de validação:&#34;, err)

    // Extrai erros por campo
    fieldErrors := errors.GetFieldErrors(err)
    for _, fieldErr := range fieldErrors {
        fmt.Printf(&#34;Campo %s: %s\n&#34;, fieldErr.Field, fieldErr.Message)
    }

case errors.IsInsufficientBalanceError(err):
    // Trata erro específico financeiro
    fmt.Println(&#34;Saldo insuficiente:&#34;, err)

case errors.IsRateLimitExceededError(err):
    // Implementa backoff e retry
    fmt.Println(&#34;Limite de requisições excedido, aguardando:&#34;, err)
    time.Sleep(exponentialBackoff(attempt))

case errors.IsAuthenticationError(err):
    // Problema com autenticação
    fmt.Println(&#34;Erro de autenticação, renovando token:&#34;, err)
    renewToken()
}</code></pre>

<p>Adicionalmente, nossos erros incluem:</p>
<ul>
<li>Categorização clara (validação, autenticação, rede, etc)</li>
<li>Detalhes específicos por domínio financeiro (saldo insuficiente, limites, etc)</li>
<li>Códigos de erro e status HTTP associados</li>
<li>Sugestões de correção para o desenvolvedor</li>
<li>Integração com observabilidade (geração de span de erro)</li>
<li>Testes de stress e verificação de escalabilidade</li>
</ul>
<p>Uma característica distintiva da nossa SDK foi o desenvolvimento de uma suite robusta de testes de stress:</p>

  <pre><code class="language-go">// trecho do código da suite de stress testing
func (st *StressTest) Run(ctx context.Context) error {
    logger := st.observability.GetLogger()
    logger.Info(&#34;Iniciando teste de stress&#34;, &#34;workers&#34;, st.config.ConcurrentWorkers)

    // Preparar ambiente de teste
    if err := st.SetupTestEnvironment(ctx); err != nil {
        return fmt.Errorf(&#34;falha ao configurar ambiente: %w&#34;, err)
    }

    // Executar até interrupção ou duração configurada
    var wg sync.WaitGroup
    ctx, cancel := context.WithCancel(ctx)
    defer cancel()

    // Inicia monitoramento de métricas
    st.metrics = NewMetricsCollector(st.observability)
    go st.metrics.Start(ctx)

    // Inicia workers para gerar carga
    for i := 0; i &lt; st.config.ConcurrentWorkers; i&#43;&#43; {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            st.runWorker(ctx, workerID)
        }(i)
    }

    // Aguarda conclusão
    wg.Wait()
    logger.Info(&#34;Teste de stress concluído&#34;, &#34;transações&#34;, st.metrics.TotalTransactions())

    return nil
}</code></pre>

<p>Esta suite nos permitiu:</p>
<ul>
<li>Validar o comportamento sob carga extrema (50.000+ tx/s ou modelos de 1:1 em conta com 10000+ tx/s)</li>
<li>Identificar e corrigir bottlenecks antes do lançamento</li>
<li>Verificar o comportamento de mecanismos de retry e resiliência</li>
<li>Testar a degradação graceful sob falhas parciais</li>
<li>Validar limites de recursos (memória, CPU, conexões, e o próprio sistema distribuído)</li>
</ul>
<p>No ponto específico de validar limites de recursos e do sistema distribuído, utilizamos o pumba para simular cenários de caos (em docker), e isso nos ajudou a identificar pontos interessantes na implementação do próprio backend.</p>
<h2 id="documentação-direcionada-por-exemplos">documentação direcionada por exemplos<a href="#documentação-direcionada-por-exemplos" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Percebemos que bons exemplos são mais valiosos que documentação abstrata. Por isso, demos ênfase especial a exemplos práticos:</p>

  <pre><code class="language-go">// exemplo completo de transferência entre contas
func ExampleTransferBetweenAccounts() {
    // Inicializar cliente
    c, err := client.New(
        client.WithAuthToken(os.Getenv(&#34;MIDAZ_TOKEN&#34;)),
        client.UseAllAPIs(),
    )
    if err != nil {
        log.Fatalf(&#34;Erro inicializando cliente: %v&#34;, err)
    }

    // Definir detalhes da transação
    input := &amp;models.TransactionDSLInput{
        Description: &#34;Transferência para pagamento de aluguel&#34;,
        Send: &amp;models.DSLSend{
            Asset: &#34;BRL&#34;,
            Value: 150000, // R$ 1.500,00
            Scale: 2,
            Source: &amp;models.DSLSource{
                From: []models.DSLFromTo{
                    {
                        Account: &#34;conta-origem-123&#34;,
                        Amount: &amp;models.DSLAmount{
                            Asset: &#34;BRL&#34;,
                            Value: 150000,
                            Scale: 2,
                        },
                    },
                },
            },
            Distribute: &amp;models.DSLDistribute{
                To: []models.DSLFromTo{
                    {
                        Account: &#34;conta-destino-456&#34;,
                        Amount: &amp;models.DSLAmount{
                            Asset: &#34;BRL&#34;,
                            Value: 150000,
                            Scale: 2,
                        },
                    },
                },
            },
        },
        Metadata: map[string]any{
            &#34;referencia&#34;: &#34;aluguel-julho-2025&#34;,
            &#34;categoria&#34;: &#34;moradia&#34;,
        },
    }

    // Executar a transação
    tx, err := c.Entity.Transactions.CreateTransactionWithDSL(
        context.Background(),
        &#34;org-exemplo&#34;,
        &#34;ledger-principal&#34;,
        input,
    )
    if err != nil {
        log.Fatalf(&#34;Erro na transferência: %v&#34;, err)
    }

    fmt.Printf(&#34;Transferência realizada com sucesso! ID: %s\n&#34;, tx.ID)
}</code></pre>

<p>Cada exemplo está acompanhado de comentários detalhados e cobrimos todos os cenários principais:</p>
<ul>
<li>Criação de entidades (organizações, contas, etc)</li>
<li>Operações financeiras (transferências, depósitos, saques)</li>
<li>Consultas e relatórios (balanços, extratos, histórico)</li>
<li>Workflows completos (onboarding, transações)</li>
</ul>
<p>A vantagem da unificação de interface
Falando um pouco sobre a vantagem de unificar múltiplas APIs de backend sob uma interface coerente: no mundo financeiro, frequentemente temos APIs separadas para diferentes domínios:</p>
<ul>
<li>API de onboarding (organizações, contas)</li>
<li>API de transactions (transferências, saldos)</li>
<li>API de compliance (KYC, AML)</li>
<li>API de reporting (relatórios, extratos)</li>
<li>etc etc etc</li>
</ul>
<p>Cada uma com suas peculiaridades e convenções. Nossa SDK unifica todas sob uma única interface consistente:</p>

  <pre><code class="language-go">// Mesmo padrão para todas as APIs, independente do backend
// API de onboarding
organization, err := client.Entity.Organizations.CreateOrganization(ctx, input)

// API de transactions
transaction, err := client.Entity.Transactions.CreateTransaction(ctx, orgID, ledgerID, input)

// API de balanços
balance, err := client.Entity.Accounts.GetBalance(ctx, orgID, ledgerID, accountID)</code></pre>

<p>Esta unificação traz benefícios significativos para o desenvolvedor em si:</p>
<ul>
<li>Reduz a curva de aprendizado para novos desenvolvedores</li>
<li>Abstrai as diferenças de implementação entre serviços</li>
<li>Permite evolução independente do backend e frontend</li>
<li>Facilita migração entre diferentes versões de APIs</li>
</ul>
<p>A discussão sobre fronteiras: o que aprendemos
Voltando à questão inicial sobre as fronteiras de responsabilidade entre servidor e cliente, concluímos que a resposta não é binária. Em vez disso, é um espectro que depende do contexto:</p>
<ul>
<li>Validação: tanto cliente quanto servidor devem validar - cliente para UX e DevEx, servidor para segurança</li>
<li>Resiliência: principalmente responsabilidade do cliente, com suporte do servidor (idempotência, o que nossa API também trata com uma option específica de WithIdempotency())</li>
<li>Performance: responsabilidade compartilhada, com otimizações específicas em cada lado</li>
<li>Domínio: o servidor define o modelo, mas o cliente pode enriquecê-lo com abstrações úteis</li>
</ul>
<p>O que ficou claro é que SDKs não são meros wrappers de API - elas são produtos completos que precisam considerar toda a experiência do desenvolvedor e os requisitos específicos do domínio.</p>
<h2 id="trade-offs-e-desafios-de-design-importantes">trade-offs e desafios de design importantes<a href="#trade-offs-e-desafios-de-design-importantes" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Durante o desenvolvimento da SDK, nos confrontamos com vários trade-offs importantes que impactam diretamente desenvolvedores e usuários:</p>
<ul>
<li>Validação no cliente vs. sincronização com o servidor</li>
<li>A implementação de validações robustas no cliente traz benefícios claros de performance e experiência do desenvolvedor, mas também introduz um desafio:</li>
</ul>

  <pre><code class="language-go">// Se estas regras de validação mudam no servidor...
if !assetCodePattern.MatchString(asset) {
    return fmt.Errorf(&#34;invalid asset code format: %s (must be 3-4 uppercase letters)&#34;, asset)
}</code></pre>

<p>Este é um trade-off significativo:</p>
<ul>
<li>Vantagem: redução de latência e feedback instantâneo</li>
<li>Desvantagem: potencial divergência entre regras cliente/servidor se os clientes não atualizarem a SDK</li>
</ul>
<p>Nossa solução foi documentar claramente a necessidade de atualizações regulares e fornecer testes que ajudam a detectar divergências de validação, além de fazer um robusto linking entre models do cliente e do servidor.</p>
<ul>
<li>Filosofia de tratamento de erros: o que tratar automaticamente?</li>
<li>Uma decisão crítica foi determinar quais erros a SDK deveria tratar automaticamente versus quais deveriam ser expostos para o backend:</li>
</ul>

  <pre><code class="language-go">// Erros tratados automaticamente pela SDK
if errors.IsTemporaryNetworkError(err) || errors.IsRateLimitExceeded(err) {
    // Aplicar retry automaticamente
    return retry.Do(ctx, operation)
}

// Erros que são propagados ao aplicativo
if errors.IsBusinessRuleViolation(err) || errors.IsValidationError(err) {
    // O desenvolvedor precisa tratar estes casos explicitamente
    return err
}</code></pre>

<p>Adotamos a filosofia de que:</p>
<ul>
<li>
<p>Erros transientes de infraestrutura/rede são tratados pela SDK</p>
</li>
<li>
<p>Erros de domínio financeiro ou validação são propagados para permitir tratamento adequado pelo backend</p>
</li>
<li>
<p>Erros críticos (autenticação, permissões) são propagados com contexto enriquecido para facilitar diagnóstico</p>
</li>
<li>
<p>Integração de observabilidade: o equilíbrio entre intrusão e visibilidade</p>
</li>
<li>
<p>A observabilidade é crítica em sistemas financeiros, mas quanto a SDK deve impor versus oferecer como opcional? Aqui é um caso a parte. Remodelamos toda a stack de observabilidade (usando opentelemetry) para que o desenvolvedor possa escolher o que ele quer e o que ele não quer, sem sermos &ldquo;opinionated&rdquo; com relação ao tema &ndash; bem diferente do contexto do midaz open-source, que é mais &ldquo;opinionated&rdquo;.</p>
</li>
</ul>

  <pre><code class="language-go">// Abordagem não-intrusiva que adotamos:
client, err := client.New(
    // Configuração básica
    client.WithAuthToken(&#34;token&#34;),

    // Observabilidade totalmente opcional
    client.WithObservability(
        observability.WithTracing(userDefinedTraceProvider),  // opcional
        observability.WithMetrics(userDefinedMeterProvider),  // opcional
        observability.WithLogging(userDefinedLogger),         // opcional
    ),
)</code></pre>

<p>Decidimos por uma abordagem modular onde:</p>
<ul>
<li>
<p>A SDK funciona perfeitamente sem observabilidade configurada</p>
</li>
<li>
<p>Desenvolvedores podem injetar seus próprios providers de observabilidade</p>
</li>
<li>
<p>Fornecemos implementações default para casos simples</p>
</li>
<li>
<p>Instrumentamos pontos críticos nas operações financeiras para máxima visibilidade</p>
</li>
<li>
<p>Operações Assíncronas e Notificações</p>
</li>
<li>
<p>Transações financeiras frequentemente envolvem processos assíncronos. Como a SDK deve lidar com isso?</p>
</li>
</ul>

  <pre><code class="language-go">// Opção 1: Polling (implementamos inicialmente)
status, err := client.Entity.Transactions.GetTransactionStatus(ctx, txID)

// Opção 2: Webhooks (planejado para futuro)
client.Entity.Transactions.RegisterWebhookHandler(webhookHandler)

// Opção 3: Response streaming (planejado para futuro)
stream, err := client.Entity.Transactions.WatchTransaction(ctx, txID)
for update := range stream.Updates() {
    // Processar atualizações em tempo real
}</code></pre>

<p>Nossa abordagem foi evolutiva. Tomamos uma decisão de implementar o básico agora, mas permitindo uma modelagem como a acima exposta:</p>
<p>Começamos com polling simples para compatibilidade ampla
Adicionaremos suporte a webhooks para notificações em tempo real
E planejamos, por fim, streaming de atualizações para casos de uso mais complexos</p>
<h2 id="estratégia-de-versionamento-e-compatibilidade-planejado-para-em-breve-dado-que-estamos-na-v1-do-midaz">estratégia de versionamento e compatibilidade planejado para em breve, dado que estamos na V1 do Midaz<a href="#estratégia-de-versionamento-e-compatibilidade-planejado-para-em-breve-dado-que-estamos-na-v1-do-midaz" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>O versionamento é um desafio significativo em APIs financeiras que evoluem constantemente:</p>

  <pre><code class="language-go">// Suporte a múltiplas versões de API
client, err := client.New(
    client.WithAPIVersion(&#34;v1&#34;),  // default
    // ou
    client.WithAPIVersion(&#34;v2&#34;),  // novas funcionalidades
)

// Usando feature flags para recursos em preview
client.Entity.Transactions.CreateTransaction(
    ctx, orgID, ledgerID, input,
    transactions.WithFeatureEnabled(&#34;instant-settlement&#34;),
)</code></pre>

<p>Adotaremos uma estratégia de versionamento com múltiplas camadas:</p>
<ul>
<li>Versionamento semântico tradicional para a SDK</li>
<li>Compatibilidade com múltiplas versões de API em uma única versão da SDK</li>
<li>Feature flags para recursos experimentais</li>
<li>Aliases de métodos deprecados com warnings para facilitar migrações</li>
</ul>
<h2 id="aprendizados-para-o-futuro">aprendizados para o futuro<a href="#aprendizados-para-o-futuro" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Lançar a primeira versão de uma SDK não é o fim da jornada, mas apenas o começo. Já identificamos diversas áreas para evolução:</p>
<ul>
<li>Estratégia evolutiva: como evoluir a API sem quebrar compatibilidade? como evoluir o backend sem quebrar compatibilidade? como fazer tudo isso e mantermos o decoupling super necessário entre midaz e midaz-sdk-golang versioning</li>
<li>Abstrações de domínio: quais abstrações de nível superior devemos oferecer para simplificar fluxos comuns? que tal evoluirmos para DoWithdrawal, DoDeposit, DoTransfer, etc, fazendo a abstração entre a conta @external/asset e o domínio de transações. que tal evoluirmos para sdk apis 100% fluentes?</li>
<li>Balanceamento de responsabilidades: conforme o produto evolui, qual o equilíbrio ideal entre lógica no servidor e no cliente? afinal, não queremos obrigar nossos clientes a usarem a sdk, até pq não conseguiremos manter sdks em um número grande de linguagens</li>
<li>Extensibilidade: como permitir que usuários estendam a SDK para seus casos específicos? o fato de sermos open-source facilita isso e chama o público para nos ajudar, mas sabemos da nossa responsabilidade como principais mantenedores do midaz e sua stack</li>
</ul>
<p>Particularmente interessante é a questão dos modelos de domínio. Por exemplo, em vez de apenas oferecer a API para criar uma transação, devemos evoluir para oferecer construções de mais alto nível:</p>

  <pre><code class="language-go">// Potencial evolução futura - Abstrações de domínio mais ricas
// Em vez de apenas criar transações
tx, err := client.Entity.Transactions.CreateTransaction(ctx, orgID, ledgerID, createTxInput)

// Oferecer fluxos de domínio completos
transferResult, err := client.Workflows.DoTransfer(ctx, transferOptions)
paymentResult, err := client.Workflows.DoPayment(ctx, paymentOptions)
fxResult, err := client.Workflows.DoForeignExchangeTransfer(ctx, fxOptions)</code></pre>

<h2 id="o-padrão-functional-options-flexibilidade-sem-complexidade">o padrão functional options: flexibilidade sem complexidade<a href="#o-padrão-functional-options-flexibilidade-sem-complexidade" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>um padrão de design que merece destaque especial na nossa sdk é o uso extensivo de functional options (ou a implementação parcial de fluent apis). este padrão permite configuração flexível sem comprometer a legibilidade ou simplicidade:</p>

  <pre><code class="language-go">// definição básica do padrão
type ClientOption func(*Client) error

func WithTimeout(timeout time.Duration) ClientOption {
    return func(c *Client) error {
        if timeout &lt;= 0 {
            return errors.New(&#34;timeout must be positive&#34;)
        }
        c.httpClient.Timeout = timeout
        return nil
    }
}

// uso elegante e extensível
client, err := client.New(
    client.WithAuthToken(&#34;seu-token&#34;),
    client.WithTimeout(30 * time.Second),
    client.WithRetries(3),
    client.WithObservability(true),
)</code></pre>

<p>este padrão oferece múltiplas vantagens:</p>
<ul>
<li>evita a explosão de construtores para diferentes combinações de opções</li>
<li>permite adicionar novos parâmetros sem quebrar código existente</li>
<li>facilita testes e configurações condicionais</li>
<li>proporciona validação no momento da configuração</li>
<li>permite opções compostas que aplicam múltiplas configurações</li>
</ul>
<p>aplicamos o mesmo padrão em diversos níveis da sdk, não apenas na inicialização do cliente:</p>

  <pre><code class="language-go">// nível de operação - opções específicas por operação
tx, err := client.Entity.Transactions.CreateTransaction(
    ctx, orgID, ledgerID, input,
    transactions.WithIdempotencyKey(&#34;unique-key-123&#34;),
    transactions.WithPriority(transactions.PriorityHigh),
)

// nível de entidade - configurações por domínio
accountSvc := client.Entity.Accounts.WithOptions(
    accounts.WithCaching(true),
    accounts.WithValidation(accounts.ValidationStrict),
)</code></pre>

<h2 id="conclusão">conclusão<a href="#conclusão" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>construir a sdk do midaz foi uma jornada de aprendizado e de um estado de flow absurdo. as complexidades de sistemas distribuídos, especialmente no domínio financeiro, e as decisões que tomamos - desde validação robusta no cliente até mecanismos avançados de resiliência e performance - foram todas guiadas pela pergunta: &ldquo;o que tornaria a vida do desenvolvedor mais fácil e o sistema mais confiável?&rdquo;</p>
<p>no final, a fronteira entre cliente e servidor é mais sobre colaboração do que separação. uma boa sdk não apenas encapsula uma api, mas amplia suas capacidades e protege contra suas limitações.</p>
<p>a gestão cuidadosa dos trade-offs que destacamos - validação no cliente versus sincronização com o servidor, tratamento automático versus exposição de erros, modularidade de observabilidade, e estratégias para operações assíncronas - moldou uma sdk que equilibra simplicidade e poder.</p>
<p>se você estiver construindo uma sdk, especialmente para sistemas críticos como o financeiro, sugiro considerar cuidadosamente onde colocar essas fronteiras de responsabilidade. sua resposta pode não ser a mesma que a nossa, mas fazer a pergunta já é um excelente começo.</p>
<p>bora?</p>
<p>para quem quiser explorar mais, a midaz sdk está disponível em nosso github e inclui extensos exemplos de uso. os exemplos de código e implementações de referência fornecem insights valiosos sobre como implementar padrões robustos em sdks financeiras.</p>
<p>o que você acha? onde você traçaria a linha entre responsabilidades de cliente e servidor em uma sdk? aproveita e dá uma estrelinha pra gente! o midaz está aqui, nosso frontend console está aqui, e nossa sdk está aqui.</p>
<p>next steps?
port para js. quite a challenge!</p>
<p>beijos,
fred.</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h"></span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="http://localhost:1313/posts/gerenciando-dados-de-clientes-com-o-plugin-crm-do-midaz/" class="button inline prev">
        &lt; [<span class="button__text">gerenciando dados de clientes com o plugin crm do midaz: segurança e flexibilidade em primeiro lugar</span>]
      </a>
    
    
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="http://localhost:1313/bundle.min.js"></script>





  
</div>

</body>
</html>
